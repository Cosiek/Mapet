// Generated by CoffeeScript 1.9.3
(function() {
  var MapHandler, MarkersMode, Mode, PolygonMode,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Mode = (function() {
    function Mode() {}

    Mode.prototype.markerOptions = {};

    Mode.prototype.initialize = function(options) {
      var opt, results;
      results = [];
      for (opt in options) {
        results.push(this[opt] = options[opt]);
      }
      return results;
    };

    Mode.prototype.drawFromInitialData = function(data) {
      return null;
    };

    Mode.prototype.onClick = function(point) {
      return null;
    };

    Mode.prototype.onRightClick = function(point) {
      return null;
    };

    Mode.prototype.onMapBoundsChanged = function() {
      return null;
    };

    Mode.prototype.start = function() {
      return null;
    };

    Mode.prototype.clear = function() {
      return null;
    };

    Mode.prototype.getValue = function() {
      return null;
    };

    Mode.prototype.createMarker = function(latLng, options, callbacks) {
      var ev, key, marker, opts;
      if (!(latLng.lat && latLng.lng)) {
        latLng = new google.maps.LatLng(latLng[0], latLng[1]);
      }
      opts = {
        'map': this.map,
        'position': latLng
      };
      for (key in this.markerOptions) {
        opts[key] = this.markerOptions[key];
      }
      for (key in options) {
        opts[key] = options[key];
      }
      marker = new google.maps.Marker(opts);
      if (callbacks) {
        for (ev in callbacks) {
          google.maps.event.addListener(marker, ev, (function(_this) {
            return function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              args.splice(0, 0, _this);
              args.splice(0, 0, marker);
              return callbacks[ev](args);
            };
          })(this));
        }
      }
      return marker;
    };

    Mode.prototype.removeMarker = function(marker) {
      if (marker) {
        marker.setMap(null);
        return google.maps.event.clearInstanceListeners(marker);
      }
    };

    return Mode;

  })();

  MarkersMode = (function(superClass) {
    extend(MarkersMode, superClass);

    function MarkersMode() {
      return MarkersMode.__super__.constructor.apply(this, arguments);
    }

    MarkersMode.prototype.markers = [];

    MarkersMode.prototype.removableMarkers = true;

    MarkersMode.prototype.onClick = function(point) {
      var marker;
      marker = this.createMarker(point.latLng);
      if (this.removableMarkers) {
        google.maps.event.addListener(marker, 'rightclick', (function(_this) {
          return function() {
            return _this.removeMarker(marker);
          };
        })(this));
      }
      this.markers.push(marker);
      return marker;
    };

    MarkersMode.prototype.removeMarker = function(marker) {
      var idx;
      idx = this.markers.indexOf(marker);
      this.markers.splice(idx, 1);
      return MarkersMode.__super__.removeMarker.call(this, marker);
    };

    MarkersMode.prototype.clear = function() {
      var marker, results;
      results = [];
      while (this.markers.length) {
        marker = this.markers[this.markers.length - 1];
        results.push(this.removeMarker(marker));
      }
      return results;
    };

    MarkersMode.prototype.getValue = function() {
      var i, len, marker, markerPosition, positions, ref;
      positions = [];
      ref = this.markers;
      for (i = 0, len = ref.length; i < len; i++) {
        marker = ref[i];
        markerPosition = marker.getPosition();
        positions.push([markerPosition.lat(), markerPosition.lng()]);
      }
      return positions;
    };

    MarkersMode.prototype.drawFromInitialData = function(data) {

      /*
      Example data is:
      {
          'coords': [[51.51, 23.23, {attr: 'optional'}], [52.00, 23.00]],
          'options': {draggable:false}, v
          'callbacks': {'click': (arg) -> console.log('klik ' + arg)}
      }
      If data has no 'coords' attribute, then assume it is just a list of
      coordinates (like: [[51.51, 23.23, {attr: 'optional'}], [52.00, 23.00]])
       */
      var attr, coord, coords, i, len, marker, results;
      if (!data.coords) {
        coords = data;
      } else {
        coords = data.coords;
      }
      results = [];
      for (i = 0, len = coords.length; i < len; i++) {
        coord = coords[i];
        marker = this.createMarker(coord, data.options, data.callbacks);
        if (coord[2]) {
          for (attr in coord[2]) {
            marker[attr] = coord[2][attr];
          }
        }
        results.push(this.markers.push(marker));
      }
      return results;
    };

    return MarkersMode;

  })(Mode);

  PolygonMode = (function(superClass) {
    extend(PolygonMode, superClass);

    function PolygonMode() {
      return PolygonMode.__super__.constructor.apply(this, arguments);
    }

    PolygonMode.prototype.markers = [];

    PolygonMode.prototype.polygons = [];

    PolygonMode.prototype.selected = null;

    PolygonMode.prototype.markerOptions = {
      'icon': 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png'
    };

    PolygonMode.prototype.polygonOptions = {
      strokeColor: '#BA89CC',
      strokeOpacity: 0.8,
      strokeWeight: 2,
      fillColor: '#BA89CC',
      fillOpacity: 0.35,
      editable: false,
      draggable: false,
      geodesic: true
    };

    PolygonMode.prototype.onClick = function(point) {
      var polygon;
      if (this.selected) {
        PolygonMode.__super__.onClick.call(this, point);
        return this.redrawPolygon();
      } else {
        return polygon = new Polygon();
      }
    };

    PolygonMode.prototype.onRightClick = function(point) {
      this.selected = null;
      return this.redrawPolygon();
    };

    PolygonMode.prototype.removeMarker = function(marker) {
      PolygonMode.__super__.removeMarker.call(this, marker);
      return this.redrawPolygon();
    };

    PolygonMode.prototype.redrawPolygon = function() {
      var i, len, locations, marker, ref;
      this.clearPolygon();
      if (this.markers.length > 2) {
        locations = [];
        ref = this.markers;
        for (i = 0, len = ref.length; i < len; i++) {
          marker = ref[i];
          locations.push(marker.position);
        }
        this.polygonOptions.paths = locations;
        this.polygon = new google.maps.Polygon(this.polygonOptions);
        this.polygon.setMap(this.map);
        return google.maps.event.addListener(this.polygon, 'click', (function(_this) {
          return function(point) {
            return google.maps.event.trigger(_this.map, 'click', point);
          };
        })(this));
      }
    };

    PolygonMode.prototype.clearPolygon = function() {
      if (this.polygon) {
        this.polygon.setMap(null);
        return google.maps.event.clearInstanceListeners(this.polygon);
      }
    };

    PolygonMode.prototype.clear = function() {
      this.clearPolygon();
      return PolygonMode.__super__.clear.call(this);
    };

    PolygonMode.prototype.drawFromInitialData = function(data) {
      PolygonMode.__super__.drawFromInitialData.call(this, data);
      return this.redrawPolygon();
    };

    return PolygonMode;

  })(MarkersMode);

  MapHandler = (function() {
    function MapHandler() {}

    MapHandler.prototype.map = null;

    MapHandler.prototype.mapContainerSelector = '#map-container';

    MapHandler.prototype.initialMapOptions = {
      center: new google.maps.LatLng(52.21885952070011, 20.983983278274536),
      zoom: 18,
      mapTypeId: google.maps.MapTypeId.ROADMAP
    };

    MapHandler.prototype.mode = 'none';

    MapHandler.prototype.availableModes = {
      'BaseMode': Mode,
      'MarkersMode': MarkersMode,
      'PolygonMode': PolygonMode
    };

    MapHandler.prototype.modes = {};

    MapHandler.prototype.handler = null;

    MapHandler.prototype.editable = true;

    MapHandler.prototype.initializeMap = function(mapContainerSelector) {
      var className, id, mapContainer;
      mapContainerSelector = mapContainerSelector || this.mapContainerSelector;
      if (mapContainerSelector.charAt(0) === '.') {
        className = mapContainerSelector.slice(1);
        mapContainer = document.getElementsByClassName(className)[0];
      } else if (mapContainerSelector.charAt(0) === '#') {
        id = mapContainerSelector.slice(1);
        mapContainer = document.getElementById(id);
      }
      this.map = new google.maps.Map(mapContainer, this.initialMapOptions);
      return this.bindMapEvents();
    };

    MapHandler.prototype.initializeMode = function(modeName, modeCodename, modeOptions) {
      var optName;
      if (modeOptions == null) {
        modeOptions = {};
      }
      if (this.modes[modeName]) {
        return null;
      }
      if (!modeCodename) {
        modeCodename = modeName;
      }
      if (!this.availableModes[modeCodename]) {
        throw Error('Unknown work mode: ' + String(modeCodename));
      }
      this.modes[modeName] = new this.availableModes[modeCodename]();
      for (optName in modeOptions) {
        this.modes[modeName][optName] = modeOptions[optName];
      }
      this.modes[modeName].mapHandler = this;
      this.modes[modeName].map = this.map;
      return this.modes[modeName].initialize();
    };

    MapHandler.prototype.centerMap = function(points) {
      var coords, i, j, latLng, latLngs, latlngbounds, len, len1;
      if (!points) {
        return;
      }
      latLngs = [];
      for (i = 0, len = points.length; i < len; i++) {
        coords = points[i];
        if (coords.lat && coords.lng) {
          latLng = coords;
        } else {
          latLng = new google.maps.LatLng(coords[0], coords[1]);
        }
        latLngs.push(latLng);
      }
      if (latLngs.length === 1) {
        return this.map.setCenter(latLngs[0]);
      } else {
        latlngbounds = new google.maps.LatLngBounds();
        for (j = 0, len1 = latLngs.length; j < len1; j++) {
          latLng = latLngs[j];
          latlngbounds.extend(latLng);
        }
        return this.map.fitBounds(latlngbounds);
      }
    };

    MapHandler.prototype.bindMapEvents = function() {
      var mapUpdater;
      google.maps.event.addListener(this.map, 'click', (function(_this) {
        return function(point) {
          if (_this.handler && _this.editable) {
            return _this.handler.onClick(point);
          }
        };
      })(this));
      google.maps.event.addListener(this.map, 'rightclick', (function(_this) {
        return function(point) {
          if (_this.handler && _this.editable) {
            return _this.handler.onRightClick(point);
          }
        };
      })(this));
      mapUpdater = {
        'bounds_changed_timeout': null
      };
      return google.maps.event.addListener(this.map, 'bounds_changed', (function(_this) {
        return function() {
          if (_this.handler) {
            clearTimeout(mapUpdater.boundsChangedTimeout);
            if (_this.eventDelayTime) {
              return mapUpdater.boundsChangedTimeout = setTimeout(_this.handler.onMapBoundsChanged, _this.eventDelayTime);
            } else {
              return _this.handler.onMapBoundsChanged();
            }
          }
        };
      })(this));
    };

    MapHandler.prototype.clearMap = function() {
      var mode, results;
      results = [];
      for (mode in this.modes) {
        results.push(this.modes[mode].clear());
      }
      return results;
    };

    MapHandler.prototype.changeMode = function(modeName, modeCodename) {
      if (modeName === 'none') {
        this.mode = modeName;
        this.handler = null;
      }
      if (!this.modes[modeName]) {
        this.initializeMode(modeName, modeCodename);
      }
      this.mode = modeName;
      this.handler = this.modes[modeName];
      return this.handler.start();
    };

    return MapHandler;

  })();

  window.MapHandler = MapHandler;

}).call(this);
